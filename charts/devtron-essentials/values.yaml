argo-cd:
  enabled: false
  customSelectorLabels: {}
    # devtron.ai/custom-labels : argo-cd
  crds:
    install: true  #if you are upgrading make it as false 
    keep: true

  applicationSet:
    enabled: false
  configs:
    cm:
      accounts.devtron: apiKey,login
      create: true
      resource.ignoreResourceUpdatesEnabled: "false"
      resource.compareoptions: |
        ignoreAggregatedRoles: true
      repositories: |-
        - name: devtron
          type: helm
          url: https://helm.devtron.ai
        - name: fluent
          type: helm
          url: https://fluent.github.io/helm-charts
        - name: nginx-ingress
          type: helm
          url: https://kubernetes.github.io/ingress-nginx
        - name: elastic
          type: helm
          url: https://helm.elastic.co
        - name: bitnami
          type: helm
          url: https://charts.bitnami.com/bitnami
        - name: prometheus-community
          type: helm
          url:  https://prometheus-community.github.io/helm-charts
        - name: jetstack
          type: helm
          url:  https://charts.jetstack.io
        - name: metrics-server
          type: helm
          url:  https://kubernetes-sigs.github.io/metrics-server
        - name: autoscaler
          type: helm
          url:  https://kubernetes.github.io/autoscaler
        - name: external-secrets
          type: helm
          url:  https://charts.external-secrets.io
        - name: kedacore
          type: helm
          url:  https://kedacore.github.io/charts
      resource.customizations: "kubernetes-client.io/ExternalSecret:\n  health.lua: |\n    hs = {}\n    if obj.status ~= nil then\n        if obj.status.status ~= nil then\n            hs.status = \"Degraded\"\n            hs.message = obj.status.status\n        else\n        hs.status = \"Healthy\"\n        end\n    else\n        hs.status = \"Healthy\"\n    end\n    return hs\nargoproj.io/Rollout:\n  health.lua: |\n    function getNumberValueOrDefault(field)\n        if field ~= nil then\n            return field\n        end\n        return 0\n    end          \n    function checkPaused(obj)\n        hs = {}\n        local paused = false\n        if obj.status.verifyingPreview ~= nil then\n        paused = obj.status.verifyingPreview\n        elseif obj.spec.paused ~= nil then\n        paused = obj.spec.paused\n        end\n\n        if paused then\n        hs.status = \"Suspended\"\n        hs.message = \"Rollout is paused\"\n        return hs\n        end\n        return nil\n    end    \n    function checkReplicasStatus(obj)\n        hs = {}\n        replicasCount = getNumberValueOrDefault(obj.spec.replicas)\n        replicasStatus = getNumberValueOrDefault(obj.status.replicas)\n        updatedReplicas = getNumberValueOrDefault(obj.status.updatedReplicas)\n        availableReplicas = getNumberValueOrDefault(obj.status.availableReplicas)\n\n        if updatedReplicas < replicasCount then\n        hs.status = \"Progressing\"\n        hs.message = \"Waiting for roll out to finish: More replicas need to be updated\"\n        return hs\n        end\n        -- Since the scale down delay can be very high, BlueGreen does not wait for all the old replicas to scale\n        -- down before marking itself healthy. As a result, only evaluate this condition if the strategy is canary.\n        if obj.spec.strategy.canary ~= nil and replicasStatus > updatedReplicas then\n        hs.status = \"Progressing\"\n        hs.message = \"Waiting for roll out to finish: old replicas are pending termination\"\n        return hs\n        end\n        if availableReplicas < updatedReplicas then\n        hs.status = \"Progressing\"\n        hs.message = \"Waiting for roll out to finish: updated replicas are still becoming available\"\n        return hs\n        end\n        return nil\n    end    \n\n    function statusfromcondition(obj)  \n        local hs={}\n        for _, condition in ipairs(obj.status.conditions) do\n            if condition.type == \"InvalidSpec\" then\n                hs.status = \"Degraded\"\n                hs.message = condition.message\n            return hs\n            end\n            if condition.type == \"Progressing\" and condition.reason == \"RolloutAborted\" then\n                hs.status = \"Degraded\"\n                hs.message = condition.message\n            return hs\n            end\n            if condition.type == \"Progressing\" and condition.reason == \"ProgressDeadlineExceeded\" then\n                hs.status = \"Degraded\"\n                hs.message = condition.message\n            return hs\n            end\n        end\n        return nil\n    end    \n\n    function statusfrompodhash(obj)    \n        local hs={}\n        if obj.spec.strategy.blueGreen ~= nil then\n            isPaused = checkPaused(obj)\n            if isPaused ~= nil then\n                return isPaused\n            end\n            replicasHS = checkReplicasStatus(obj)\n            if replicasHS ~= nil then\n                return replicasHS\n            end\n            if obj.status.blueGreen ~= nil and obj.status.blueGreen.activeSelector ~= nil and obj.status.blueGreen.activeSelector == obj.status.currentPodHash then\n                hs.status = \"Healthy\"\n                hs.message = \"The active Service is serving traffic to the current pod spec\"\n                return hs\n            end\n            hs.status = \"Progressing\"\n            hs.message = \"The current pod spec is not receiving traffic from the active service\"\n            return hs\n        end\n        if obj.spec.strategy.recreate ~= nil then\n            isPaused = checkPaused(obj)\n            if isPaused ~= nil then\n                return isPaused\n            end\n            replicasHS = checkReplicasStatus(obj)\n            if replicasHS ~= nil then\n                return replicasHS\n            end\n            if obj.status.recreate ~= nil and obj.status.recreate.currentRS ~= nil and obj.status.recreate.currentRS == obj.status.currentPodHash then\n                hs.status = \"Healthy\"\n                hs.message = \"Rollout is successful\"\n                return hs\n            end\n            hs.status = \"Progressing\"\n            hs.message = \"Rollout is in progress\"\n            return hs\n        end\n        if obj.spec.strategy.canary ~= nil then\n            if obj.status.stableRS ~= nil then\n            currentRSIsStable = obj.status.stableRS == obj.status.currentPodHash\n            end\n            if obj.status.canary.stableRS ~= nil then\n            currentRSIsStable = obj.status.canary.stableRS == obj.status.currentPodHash\n            end                \n            if obj.spec.strategy.canary.steps ~= nil and table.getn(obj.spec.strategy.canary.steps) > 0 then\n            stepCount = table.getn(obj.spec.strategy.canary.steps)\n            if obj.status.currentStepIndex ~= nil then\n                currentStepIndex = obj.status.currentStepIndex\n                isPaused = checkPaused(obj)\n                if isPaused ~= nil then\n                return isPaused\n                end\n            \n                if paused then\n                hs.status = \"Suspended\"\n                hs.message = \"Rollout is paused\"\n                return hs\n                end\n                if currentRSIsStable and stepCount == currentStepIndex then\n                replicasHS = checkReplicasStatus(obj)\n                if replicasHS ~= nil then\n                    return replicasHS\n                end\n                hs.status = \"Healthy\"\n                hs.message = \"The rollout has completed all steps\"\n                return hs\n                end\n            end\n            hs.status = \"Progressing\"\n            hs.message = \"Waiting for rollout to finish steps\"\n            return hs\n            end\n\n            -- The detecting the health of the Canary deployment when there are no steps\n            replicasHS = checkReplicasStatus(obj)\n            if replicasHS ~= nil then\n            return replicasHS\n            end\n            if currentRSIsStable then\n            hs.status = \"Healthy\"\n            hs.message = \"The rollout has completed canary deployment\"\n            return hs\n            end\n            hs.status = \"Progressing\"\n            hs.message = \"Waiting for rollout to finish canary deployment\"\n        end\n\n\n        return hs\n    end   \n\n    -- Main Code\n    hs = {}\n    if obj.status.phase ~= nil then\n        if obj.status.phase == \"Paused\" then\n            hs.status = \"Progressing\"\n            hs.message = \"Rollout is paused\"    \n        elseif obj.status.phase == \"Progressing\" then\n            hs=statusfromcondition(obj) or hs\n            hs=statusfrompodhash(obj) or hs   \n        elseif obj.status.phase == \"Healthy\" then\n            hs=statusfromcondition(obj) or hs\n            hs=statusfrompodhash(obj) or hs                  \n        else\n            hs.status = obj.status.phase\n            hs.message = obj.status.message\n        end   \n    else\n        if obj.status ~= nil then\n            if obj.status.conditions ~= nil then\n                hs=statusfromcondition(obj)\n            end\n            if obj.status.currentPodHash ~= nil then\n                hs=statusfrompodhash(obj)   \n            end        \n        end\n    end        \n    return hs"

    rbac:
      policy.default: role:admin
    secret:
      createSecret: true
      extra: {}
  controller:
    replicas: 1
    extraArgs: 
      - --kubectl-parallelism-limit
      - "20"
    resources: {}
    affinity: {}
    metrics:
      enabled: true
      serviceMonitor:
        enabled: true
        interval: 2m
  redis:
    exporter:
      enabled: true
    resources: {}
    affinity: {}
    metrics:
      enabled: true
      serviceMonitor:
        enabled: true
        interval: 2m
  server:
    replicas: 1
    resources: {}
    metrics:
      enabled: true
      serviceMonitor:
        enabled: true
        interval: 2m
  repoServer:
    replicas: 1
    resources: {}
    extraArgs: 
      - --repo-cache-expiration
      - 24h
      - --parallelismlimit
      - "20"
    env: 
      - name: ARGOCD_EXEC_TIMEOUT
        value: 180s
    metrics:
      enabled: true
      serviceMonitor:
        enabled: true
        interval: 2m
  dex:
    enabled: false
  fullnameOverride: argocd
  notifications:
    enabled: false
argo-rollouts:
  fullnameOverride: rollout-controller
  enabled: false
  customSelectorLabels: {}
    # devtron.ai/custom-labels : rollout
argo-workflow:
  enabled: false
  fullnameOverride: argo-workflows
devtron-rollout:
  enabled: false
permissions:
  enabled: false
  imagePullSecret:
    name: ""
    value: ""
postgresql:
  customSelectorLabels: {}
    # devtron.ai/custom-labels : postgres
  customScripts:
    db_create.sql: |
      create database casbin;
      create database git_sensor;
      create database lens;
      create database orchestrator;
  enabled: false
  fullnameOverride: postgresql-postgresql
  image:
    pullPolicy: IfNotPresent
    registry: quay.io/devtron
    repository: postgres
    tag: "14.9"
  nodeSelector: {}
  resources: {}
  settings:
    superuser: ""
    superuserPassword: change-password
  storage:
    className: ""
    persistentVolumeClaimName: ""
    requestedSize: 30Gi
  tolerations: []
rawYaml:
  enabled: false
  data: []